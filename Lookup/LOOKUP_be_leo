### vim:ft=zsh:foldmethod=marker
## dict.leo.org search backend for lookup
## Copyright: 2009, Frank Terbeck <ft@bewatermyfriend.org>
##
## This was the first non-trivial backend for lookup. Therefore,
## it contains some guidelines on how to write backends and what they
## are expected to do.
##
## For consistency in usage among different backends, please try
## to follow the general style of this one.
##

# This should be the first thing a backend does.
# It makes sure a backend function is not run directly by a user, but
# only via lookup(), lu() or _lookup().
LOOKUP_guard || return 1

# This check is required and it should be the second thing the backend does.
# If $lookup_describe is not empty, only print a short description
# of what the backend does. Without a newline at the end!
[[ -n ${lookup_describe} ]] &&
    printf '%s' 'translations via dict.leo.org' &&
    return 0

# declare variables. Assume warncreateglobal is enabled.
local lang
local -a comp_args
local -A opts supported_langs interface_lang

# For the actual query string, always use QUERY and make it 'local -x'!
# Parts of the lookup system depend on $QUERY to be declared like this!
local -x QUERY

supported_langs=(
    ende    'english german'
    frde    'french german'
    esde    'spanish german'
    itde    'italian german'
    chde    'chinese german'
)

# Lookup backends should be self-documenting.
# You need to provide a function that prints a useful message that helps
# the user use the backend.
# DO NOT hardcode the name of the function. Always use LOOKUP_help_$backend
# and guard its definition by (( ${+functions[LOOKUP_help_$backend]} )) just
# like it is done here.
(( ${+functions[LOOKUP_help_$backend]} )) ||
function LOOKUP_help_${backend}() {
    printf 'usage: %s [-l lang] <query>\n' ${backend}
    printf '  -l <lang>     specify a language definition string\n'
    printf '\nAvailable language definition strings:\n'
    for lang in ${(k)supported_langs} ; do
        printf '%6s   - %s\n' ${lang} ${supported_langs[$lang]}
    done
}

# This call must be here, too. Just after you defined the help function.
# It handles the global -h option of lookup correctly.
LOOKUP_help ${backend} && return 0

# This test is needed, too.
# Backends are supposed to bring there own completion.
if [[ -n ${lookup_complete} ]] ; then
    # During development, you can just put a
    #return 0
    # here. That will disable completion for the backend and
    # prevent breakage for other backends.

    # completion sub-functions should be called:
    # __lookup_<backend>_<completion_feature>()
    # guard their definition by checking the $functions[] entry
    # that belongs to your sub-function.
    (( ${+functions[__lookup_leo_supported_langs]} )) ||
    function __lookup_leo_supported_langs() {
        local l
        local -a ls

        ls=()
        for l in ${(k)supported_langs}; do
            ls+=("$l:${supported_langs[$l]}")
        done
        _describe -t leo_langs 'supported languages' ls
    }

    comp_args=(
        '-l[set languages]:supported languages:__lookup_leo_supported_langs'
        '*:dict.leo.org query:true'
    )

    _arguments -s -w -A '-*' ${comp_args} && return 0
    _message 'dict.leo.org query'

    return 0
    # end of completion code #
fi

# parse possible options of the backend.
# 'zparseopts' is the recommended way of doing that.
zparseopts -A opts -D 'l:'
lang=${opts[-l]}

# all configuration should be done via zstyle
# set reasonable defaults, too.
if [[ -z ${lang} ]] ; then
    zstyle -s ":lookup:${lsys}:${backend}" default-lang lang || lang='ende'
fi

zstyle -s ":lookup:${lsys}:${backend}" interface-lang interface_lang || interface_lang='en'

# If applicable, use the remaining arguments as QUERY.
QUERY="$*"

# Call LOOKUP_query_handler() to support the -Q and -q options of lookup.
# If you want to support return values from handlers, use the
# $lookup_communicate[] hash, which is meant to be used for that. It can
# also be used to get additional information into the handler.
# See LOOKUP_be_letssingit for an example.
LOOKUP_query_handler

# Do appropriate error checking and give usage information
# if the query is empty.
if [[ -z ${(Mk)supported_langs:#$lang} ]] ; then
    printf 'Unknown language definition: '\''%s'\''.\n\n' ${lang}
    # Clear out $QUERY, so we get the usage message below.
    QUERY=''
fi
if [[ -z ${QUERY} ]] ; then
    # Here you need to use LOOKUP_help_${backend} NOT LOOKUP_help ${backend}!
    # Note the underscore! :)
    LOOKUP_help_${backend}
    return 1
fi

# Use LOOKUP_encode() for proper url encoding of the QUERY.
# Since, QUERY is the most common use case of LOOKUP_encode, it has
# a special option to handle that variable.
# For other variables you want to encode, do:
#   foo="$(LOOKUP_encode ${foo})"
LOOKUP_encode -q

# Use our browser wrapper to open the URI, it'll handle everything just right.
LOOKUP_browser "http://dict.leo.org?lang=${interface_lang}&lp=${lang}&search=${QUERY}"

# Explicitly return $?.
return $?
